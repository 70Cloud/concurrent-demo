package pers.qly.concurrent.lock;

/**
 * @Author: NoNo
 * @Description:
 * @Date: Create in 14:52 2019/2/26
 */
public class LockDemo {

    // 乐观锁：适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升，CAS 算法(j.u.c 原子类)
    // 悲观锁：适合写操作多的场景，先加锁可以保证写操作时数据正确

    // CAS Compare And Swap（比较与交换），存在三大问题
    // 1、ABA 问题(内存值原来是A，后来变成了B，然后又变成了A)
    //  如何解决：1、在变量前面添加版本号，每次变量更新的时候都把版本号加一 2、JDK 5 的 AtomicStampedReference
    // 2、循环时间长开销大：CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销
    // 3、只能保证一个共享变量的原子操作：对一个共享变量执行操作时，CAS 能够保证原子操作，
    //  但是对多个共享变量操作时，CAS 是无法保证操作的原子性的
    //  如何解决：JDK 5 的 AtomicReference(保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作)

    public static void main(String[] args) {
        // 自旋锁
        for(;;){
            // 很多时候获得锁之后短时间会很快释放，所以通过自旋的方式防止线程挂起(如果把一个线程挂起，再去 park,unpark肯定性能比自旋差)
            // 自旋锁本身是有缺点的，它不能代替阻塞。
            // 自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。
            // 如果锁被占用的时间很短，自旋等待的效果就会非常好。
            // 反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。
            // 所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）
            // 没有成功获得锁，就应当挂起线程。
        }

        // 偏向锁(一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价)
        // 锁不仅不存在竞争，并且都是由同一个线程多次获得，为了让线程获得锁的代价更低所以引入了偏向锁
        //  当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在
        //  进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指
        //  向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏
        //  向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS
        //  将对象头的偏向锁指向当前线程

        // 轻量级锁
        //  引入轻量级锁的主要目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消
        //  耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁

        // 重量级锁
        //  重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实
        //  现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。(为什么重量级锁性能低)


        // 公平锁：多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁
        // 非公平锁：多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待

        // 可重入锁：ReentrantLock 和 Synchronized 都是可重入锁（一定程度避免死锁）
        // 非可重入锁

        // 独占锁(排他锁)：该锁一次只能被一个线程所持有  ReentrantReadWriteLock 中的 WriteLock
        // 共享锁：该锁可被多个线程所持有 ReentrantReadWriteLock 中的 ReadLock
    }
}
